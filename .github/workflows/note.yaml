name: Note Workflow

on:
  workflow_dispatch:
    inputs:
      theme:
        description: 'Ë®ò‰∫ã„ÉÜ„Éº„Éû'
        required: true
        type: string
      target:
        description: 'ÊÉ≥ÂÆöË™≠ËÄÖÔºà„Éö„É´„ÇΩ„ÉäÔºâ'
        required: true
        type: string
      message:
        description: 'Ë™≠ËÄÖ„Å´‰ºù„Åà„Åü„ÅÑÊ†∏„É°„ÉÉ„Çª„Éº„Ç∏'
        required: true
        type: string
      cta:
        description: 'Ë™≠Âæå„ÅÆ„Ç¢„ÇØ„Ç∑„Éß„É≥ÔºàCTAÔºâ'
        required: true
        type: string
      tags:
        description: '„Ç´„É≥„ÉûÂå∫Âàá„Çä„Çø„Ç∞Ôºà‰ªªÊÑèÔºâ'
        required: false
        default: ''
        type: string
      is_public:
        description: 'ÂÖ¨Èñã(true)/‰∏ãÊõ∏„Åç(false)'
        required: true
        default: 'false'
        type: choice
        options:
          - 'true'
          - 'false'
      dry_run:
        description: 'ÊäïÁ®ø„Çí„Çπ„Ç≠„ÉÉ„ÉóÔºàÁîüÊàê„ÅÆ„ÅøÔºâ'
        required: true
        default: 'false'
        type: choice
        options:
          - 'true'
          - 'false'

permissions:
  contents: read

env:
  TZ: Asia/Tokyo

jobs:
  research:
    name: Research
    runs-on: ubuntu-latest
    env:
      ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
      THEME: ${{ github.event.inputs.theme }}
      TARGET: ${{ github.event.inputs.target }}
    outputs:
      research_b64: ${{ steps.collect.outputs.research_b64 }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
      - name: Install dependencies
        run: npm install
      - name: Research with Claude Code SDK
        run: |
          cat > research.mjs <<'EOF'
          import { query } from '@anthropic-ai/claude-agent-sdk';
          import fs from 'fs';
          const theme = process.env.THEME || '';
          const target = process.env.TARGET || '';
          const today = new Date().toISOString().slice(0,10);
          const artifactsDir = '.note-artifacts';
          fs.mkdirSync(artifactsDir, { recursive: true });
          const sys = [
            '„ÅÇ„Å™„Åü„ÅØÊúÄÊñ∞ÊÉÖÂ†±„ÅÆÂèéÈõÜ„Å®Ë¶ÅÁ¥Ñ„Å´ÁâπÂåñ„Åó„ÅüË∂Ö‰∏ÄÊµÅ„ÅÆ„É™„Çµ„Éº„ÉÅ„É£„Éº„Åß„Åô„ÄÇ',
            '‰∫ãÂÆü„Éô„Éº„Çπ„Éª‰∏ÄÊ¨°ÊÉÖÂ†±ÂÑ™ÂÖà„ÉªÊú¨ÊñáÂÜÖ„Å´Markdown„É™„É≥„ÇØ„ÅßÂá∫ÂÖ∏„ÇíÂüã„ÇÅËæº„ÇÄ„Åì„Å®„ÄÇ',
            'ÂçÅÂàÜ„Å™ÂàÜÈáèÔºàÁõÆÂÆâ: 2,000Ë™û‰ª•‰∏äÔºâ„ÄÇÂêÑÁØÄ„ÅßÂá∫ÂÖ∏„ÇíÊú¨Êñá„Å´Âüã„ÇÅËæº„ÇÄ„ÄÇ',
            'WebSearch „Å® WebFetch „ÇíÂøÖ„Åö‰ΩøÁî®„Åó„ÄÅ‰∏ÄÊ¨°ÊÉÖÂ†±ÔºàÂÖ¨ÁöÑÊ©üÈñ¢„ÉªË¶èÊ†º„ÉªË´ñÊñá„ÉªÂÖ¨ÂºèÔºâ„ÇíÂÑ™ÂÖà„Åô„Çã„ÄÇ',
          ].join('\n');
          const userPrompt = `‰ª•‰∏ã„ÅÆ„ÉÜ„Éº„Éû„Å®„Çø„Éº„Ç≤„ÉÉ„Éà„Å´ÂØæ„Åô„ÇãÊúÄÁµÇÁâà„ÅÆ„É™„Çµ„Éº„ÉÅ„É¨„Éù„Éº„Éà„Çí‰ΩúÊàê„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ\n„ÄêÈáçË¶Å„ÄëÈÄî‰∏≠ÁµåÈÅé„ÇÑÁ¢∫Ë™çË≥™Âïè„ÅØ‰∏ÄÂàá„Åõ„Åö„ÄÅÊúÄÁµÇ„É¨„Éù„Éº„Éà„ÅÆ„Åø„ÇíËøî„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ‰∏çÊòéÁÇπ„Åå„ÅÇ„ÇãÂ†¥Âêà„ÅØ„ÄåÂâçÊèê„Å®‰ªÆÂÆö„Äç„Çª„ÇØ„Ç∑„Éß„É≥„ÅßÁ∞°ÊΩî„Å´‰ªÆÂÆö„ÇíÊòéË®ò„Åó„Å¶„Åã„ÇâÁ∂öË°å„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ‰∫ãÂÆü„Éô„Éº„Çπ„Åß‰∏ÄÊ¨°ÊÉÖÂ†±„ÇíÊúÄÂÑ™ÂÖà„Åó„ÄÅÊú¨Êñá„Å´Markdown„É™„É≥„ÇØ„ÅßÂá∫ÂÖ∏„ÇíÂüã„ÇÅËæº„Çì„Åß„Åè„Å†„Åï„ÅÑ„ÄÇ\n---\n„ÉÜ„Éº„Éû: ${theme}\n„Çø„Éº„Ç≤„ÉÉ„Éà: ${target}\nÁèæÂú®Êó•‰ªò: ${today}`;
          const messages = [];
          for await (const msg of query({
            prompt: userPrompt,
            options: {
              systemPrompt: sys,
              allowedTools: ['WebSearch','WebFetch'],
              permissionMode: 'acceptEdits',
            },
          })) { messages.push(msg); }
          const assistantTexts = messages.filter(m=>m.type==='assistant').map(m=>{
            const c=m.message?.content; if(Array.isArray(c)){return c.filter(b=>b?.type==='text').map(b=>b.text).join('\n');} return '';
          }).filter(Boolean).join('\n\n');
          fs.writeFileSync(`${artifactsDir}/research.md`, assistantTexts || '');
          try { fs.writeFileSync(`${artifactsDir}/research_trace.json`, JSON.stringify(messages, null, 2)); } catch {}
          EOF
          node research.mjs
      - name: Collect research
        id: collect
        run: |
          b64=$(base64 -w 0 .note-artifacts/research.md 2>/dev/null || base64 .note-artifacts/research.md)
          echo "research_b64<<EOF" >> $GITHUB_OUTPUT
          echo "$b64" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
      - name: Upload research artifacts
        uses: actions/upload-artifact@v4
        with:
          name: research-artifacts
          path: |
            .note-artifacts/research.md
            .note-artifacts/research_trace.json

  write:
    name: Write
    needs: research
    runs-on: ubuntu-latest
    env:
      ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
      THEME: ${{ github.event.inputs.theme }}
      TARGET: ${{ github.event.inputs.target }}
      MESSAGE: ${{ github.event.inputs.message }}
      CTA: ${{ github.event.inputs.cta }}
      INPUT_TAGS: ${{ github.event.inputs.tags }}
    outputs:
      title: ${{ steps.collect.outputs.title }}
      draft_json_b64: ${{ steps.collect.outputs.draft_json_b64 }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
      - name: Install dependencies
        run: npm install
      - name: Restore research
        env:
          RESEARCH_B64: ${{ needs.research.outputs.research_b64 }}
        run: |
          mkdir -p .note-artifacts
          echo "$RESEARCH_B64" | base64 -d > .note-artifacts/research.md || echo "$RESEARCH_B64" | base64 --decode > .note-artifacts/research.md
      - name: Generate draft
        run: |
          cat > write.mjs <<'EOF'
          import { generateText } from 'ai';
          import { anthropic } from '@ai-sdk/anthropic';
          import fs from 'fs';
          const theme=process.env.THEME||''; const target=process.env.TARGET||''; const message=process.env.MESSAGE||''; const cta=process.env.CTA||'';
          const inputTags=(process.env.INPUT_TAGS||'').split(',').map(s=>s.trim()).filter(Boolean);
          const researchReport=fs.readFileSync('.note-artifacts/research.md','utf8');
          const modelName='claude-sonnet-4-5-20250929';
          function extractJsonFlexible(raw){const t=(raw||'').trim().replace(/\u200B/g,'');try{return JSON.parse(t);}catch{}const m=t.match(/```[a-zA-Z]*\s*([\s\S]*?)\s*```/);if(m&&m[1]){try{return JSON.parse(m[1].trim());}catch{}}const f=t.indexOf('{'),l=t.lastIndexOf('}');if(f!==-1&&l!==-1&&l>f){const c=t.slice(f,l+1);try{return JSON.parse(c);}catch{}}return null;}
          async function repairJson(raw){const sys='ÂÖ•Âäõ„Åã„Çâ {"title":string,"draftBody":string,"tags":string[]} „ÅÆJSON„ÅÆ„ÅøËøîÁ≠î„ÄÇ';const {text}=await generateText({model:anthropic(modelName),system:sys,prompt:String(raw),temperature:0,maxTokens:8000});return extractJsonFlexible(text||'');}
          function sanitizeTitle(t){
            let s=String(t||'').trim();
            s=s.replace(/^```[a-zA-Z0-9_-]*\s*$/,'').replace(/^```$/,'');
            s=s.replace(/^#+\s*/,'');
            s=s.replace(/^"+|"+$/g,'').replace(/^'+|'+$/g,'');
            s=s.replace(/^`+|`+$/g,'');
            s=s.replace(/^json$/i,'').trim();
            if(!s) s='„Çø„Ç§„Éà„É´ÔºàËá™ÂãïÁîüÊàêÔºâ';
            return s;
          }
          function deriveTitleFromText(text){
            const lines=(text||'').split(/\r?\n/).map(l=>l.trim()).filter(Boolean);
            const firstReal=lines.find(l=>!/^```/.test(l))||lines[0]||'';
            return sanitizeTitle(firstReal);
          }
          const sysWrite='note.comÂêë„ÅëÈï∑ÊñáË®ò‰∫ã„ÅÆÁîüÊàê„ÄÇJSON {title,draftBody,tags[]} „ÅßËøîÁ≠î„ÄÇdraftBody„ÅØ6000„Äú9000ÊñáÂ≠ó„ÇíÁõÆÂÆâ„Å´ÂçÅÂàÜ„Å™ÂàÜÈáè„Åß„ÄÅÁ´†„Åî„Å®„Å´Â∞èË¶ãÂá∫„Åó„Å®ÁÆáÊù°Êõ∏„Åç„ÇíÈÅ©Âàá„Å´Âê´„ÇÅ„Çã„Åì„Å®„ÄÇ';
          const prompt=[`{„ÉÜ„Éº„Éû}: ${theme}`,`{„Éö„É´„ÇΩ„Éä}: ${target}`,`{„É™„Çµ„Éº„ÉÅÂÜÖÂÆπ}: ${researchReport}`,`{‰ºù„Åà„Åü„ÅÑ„Åì„Å®}: ${message}`,`{Ë™≠Âæå„ÅÆ„Ç¢„ÇØ„Ç∑„Éß„É≥}: ${cta}`].join('\n');
          const {text}=await generateText({model:anthropic(modelName),system:sysWrite,prompt,temperature:0.7,maxTokens:30000});
          let obj=extractJsonFlexible(text||'')||await repairJson(text||'');
          let title, draftBody, tags; if(obj){title=sanitizeTitle(obj.title); draftBody=String(obj.draftBody||'').trim(); tags=Array.isArray(obj.tags)?obj.tags.map(String):[]}
          if(!title||!draftBody){ title=deriveTitleFromText(text||''); const lines=(text||'').split(/\r?\n/); draftBody=lines.slice(1).join('\n').trim()||(text||''); tags=[]}
          if(inputTags.length){tags=Array.from(new Set([...(tags||[]),...inputTags]));}
          fs.writeFileSync('.note-artifacts/draft.json',JSON.stringify({title,draftBody,tags},null,2));
          EOF
          node write.mjs
      - name: Collect draft
        id: collect
        run: |
          title=$(node -e "console.log(JSON.parse(require('fs').readFileSync('.note-artifacts/draft.json','utf8')).title)")
          b64=$(base64 -w 0 .note-artifacts/draft.json 2>/dev/null || base64 .note-artifacts/draft.json)
          echo "title<<EOF" >> $GITHUB_OUTPUT
          echo "$title" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          echo "draft_json_b64<<EOF" >> $GITHUB_OUTPUT
          echo "$b64" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
      - name: Upload draft artifact
        uses: actions/upload-artifact@v4
        with:
          name: draft-artifact
          path: .note-artifacts/draft.json

  factcheck:
    name: Fact-check (Tavily)
    needs: write
    runs-on: ubuntu-latest
    env:
      ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
      TAVILY_API_KEY: ${{ secrets.TAVILY_API_KEY }}
      TITLE: ${{ needs.write.outputs.title }}
    outputs:
      title: ${{ steps.collect.outputs.title }}
      final_b64: ${{ steps.collect.outputs.final_b64 }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
      - name: Install dependencies
        run: npm install
      # Rate limitÂØæÁ≠ñ (5ÂàÜÂæÖÊ©ü)
      - name: Cool down for Rate Limit
        run: |
          echo "Waiting 300s (5min) to reset Anthropic API rate limit..."
          sleep 300
      - name: Restore draft json
        env:
          DRAFT_JSON_B64: ${{ needs.write.outputs.draft_json_b64 }}
        run: |
          mkdir -p .note-artifacts
          echo "$DRAFT_JSON_B64" | base64 -d > .note-artifacts/draft.json || echo "$DRAFT_JSON_B64" | base64 --decode > .note-artifacts/draft.json
      - name: Fact-check with Tavily
        run: |
          cat > factcheck.mjs <<'EOF'
          import { generateText } from 'ai';
          import { anthropic } from '@ai-sdk/anthropic';
          import fs from 'fs';
          const draft=JSON.parse(fs.readFileSync('.note-artifacts/draft.json','utf8'));
          const modelName='claude-sonnet-4-5-20250929';
          const TAVILY_API_KEY=process.env.TAVILY_API_KEY||'';
          if(!TAVILY_API_KEY){ console.error('TAVILY_API_KEY is not set'); process.exit(1); }

          function extractJsonFlexible(raw){
            const t=(raw||'').trim().replace(/\u200B/g,'');
            try{ const o=JSON.parse(t); return o; }catch{}
            const fence=t.match(/```[a-zA-Z]*\s*([\s\S]*?)\s*```/); if(fence&&fence[1]){ try{ return JSON.parse(fence[1].trim()); }catch{} }
            let f=t.indexOf('{'), l=t.lastIndexOf('}'); if(f!==-1&&l!==-1&&l>f){ const cand=t.slice(f,l+1); try{ return JSON.parse(cand); }catch{} }
            f=t.indexOf('['); l=t.lastIndexOf(']'); if(f!==-1&&l!==-1&&l>f){ const cand=t.slice(f,l+1); try{ return JSON.parse(cand); }catch{} }
            return null;
          }
          function stripCodeFence(s){
            const t=String(s||'').trim();
            const m=t.match(/^```[a-zA-Z0-9_-]*\s*([\s\S]*?)\s*```\s*$/); if(m&&m[1]) return m[1].trim();
            return t;
          }

          async function proposeQueries(body){
            const sys='„ÅÇ„Å™„Åü„ÅØ‰∫ãÂÆüÊ§úË®º„ÅÆÂ∞ÇÈñÄÂÆ∂„Åß„Åô„ÄÇÂÖ•ÂäõÊú¨Êñá„Åã„ÇâÊ§úË®º„ÅåÂøÖË¶Å„Å™Âõ∫ÊúâÂêçË©û„ÉªÊï∞ÂÄ§„Éª‰∏ªÂºµ„ÇíÊäΩÂá∫„Åó„ÄÅTavilyÊ§úÁ¥¢Áî®„Å´Êó•Êú¨Ë™û„ÅÆÊ§úÁ¥¢„ÇØ„Ç®„É™„ÇíÊúÄÂ§ß10‰ª∂„ÅÆÈÖçÂàó„ÅßËøî„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇÂá∫Âäõ„ÅØJSONÈÖçÂàó„ÅÆ„Åø„ÄÇ';
            const { text } = await generateText({ model: anthropic(modelName), system: sys, prompt: String(body), temperature: 0, maxTokens: 1000 });
            const arr = extractJsonFlexible(text||'');
            return Array.isArray(arr) ? arr.map(String).filter(Boolean).slice(0,10) : [];
          }
          async function tavilySearch(q){
            const res = await fetch('https://api.tavily.com/search', {
              method: 'POST', headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ api_key: TAVILY_API_KEY, query: q, search_depth: 'advanced', max_results: 5, include_answer: true })
            });
            if(!res.ok){ return { query:q, results:[], answer:null }; }
            const json = await res.json().catch(()=>({}));
            return { query:q, results: Array.isArray(json.results)? json.results: [], answer: json.answer || null };
          }
          function formatEvidence(items){
            const lines = [];
            for(const it of items){
              lines.push(`### Ê§úÁ¥¢: ${it.query}`);
              if(it.answer){ lines.push(`Ë¶ÅÁ¥Ñ: ${it.answer}`); }
              for(const r of it.results||[]){
                const t = (r.title||'').toString(); const u = (r.url||'').toString(); const c = (r.content||'').toString().slice(0,500);
                lines.push(`- [${t}](${u})\n  ${c}`);
              }
              lines.push('');
            }
            return lines.join('\n');
          }
          async function main(){
            const queries = await proposeQueries(draft.draftBody||'');
            const results = [];
            for(const q of queries){ results.push(await tavilySearch(q)); }
            const evidence = formatEvidence(results);
            const sys=[
              '„ÅÇ„Å™„Åü„ÅØ‰∫ãÂÆüÊ§úË®º„ÅÆÂ∞ÇÈñÄÂÆ∂„Åß„Åô„ÄÇ‰ª•‰∏ã„ÅÆÂéüÁ®øÔºànoteË®ò‰∫ã„ÅÆ‰∏ãÊõ∏„ÅçÔºâ„Å´ÂØæ„Åó„ÄÅÊèê‰æõ„Åï„Çå„Åü„Ç®„Éì„Éá„É≥„ÇπÔºàTavilyÊ§úÁ¥¢ÁµêÊûúÔºâ„Å´Âü∫„Å•„Åç„ÄÅ',
              'Ë™§ÊÉÖÂ†±„ÅÆ‰øÆÊ≠£„Éª‰Ωé‰ø°È†ºÂá∫ÂÖ∏„ÅÆÁΩÆÊèõ„Éª‰ø°È†º„Åß„Åç„Çã‰∏ÄÊ¨°ÊÉÖÂ†±„ÅÆÊú¨ÊñáÂÜÖMarkdown„É™„É≥„ÇØÂüã„ÇÅËæº„Åø„ÇíË°å„Å£„Å¶„ÄÅ‰øÆÊ≠£Âæå„ÅÆÊú¨Êñá„ÅÆ„ÅøËøî„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ',
              'Êñá‰Ωì„ÉªÊßãÊàê„ÅØÂéüÁ®ø„ÇíÂ∞äÈáç„Åó„ÄÅÂøÖË¶Å„Å´Âøú„Åò„Å¶Êú¨ÊñáÊú´Â∞æ„Å´ÂèÇËÄÉÊñáÁåÆ„Çª„ÇØ„Ç∑„Éß„É≥„ÇíËøΩÂä†„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ',
            ].join('\n');
            const prompt = [ '## ÂéüÁ®ø', String(draft.draftBody||''), '', '## „Ç®„Éì„Éá„É≥„ÇπÔºàTavilyÊ§úÁ¥¢ÁµêÊûúÔºâ', evidence ].join('\n\n');
            const { text } = await generateText({ model: anthropic(modelName), system: sys, prompt, temperature: 0.3, maxTokens: 30000 });
            let body = stripCodeFence(text||'');
            let title = process.env.TITLE || draft.title || '';
            let tags = Array.isArray(draft.tags)? draft.tags: [];
            const obj = extractJsonFlexible(body);
            if (obj && typeof obj === 'object' && !Array.isArray(obj)) {
              if (obj.title) title = String(obj.title);
              const candidates = [obj.body, obj.draftBody, obj.content, obj.text];
              const chosen = candidates.find(v=>typeof v==='string' && v.trim());
              if (chosen) body = String(chosen);
              if (Array.isArray(obj.tags)) tags = obj.tags.map(String);
            }
            body = stripCodeFence(body);
            const out = { title, body, tags };
            fs.writeFileSync('.note-artifacts/final.json', JSON.stringify(out,null,2));
          }
          await main();
          EOF
          node factcheck.mjs
      - name: Upload fact-check artifact
        uses: actions/upload-artifact@v4
        with:
          name: final-artifact
          path: .note-artifacts/final.json
      - name: Collect final
        id: collect
        run: |
          title=$(node -e "console.log(JSON.parse(require('fs').readFileSync('.note-artifacts/final.json','utf8')).title)")
          b64=$(base64 -w 0 .note-artifacts/final.json 2>/dev/null || base64 .note-artifacts/final.json)
          echo "title<<EOF" >> $GITHUB_OUTPUT
          echo "$title" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          echo "final_b64<<EOF" >> $GITHUB_OUTPUT
          echo "$b64" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

  post:
    name: Post to note.com
    needs: factcheck
    if: ${{ github.event.inputs.dry_run != 'true' && needs.factcheck.result == 'success' }}
    runs-on: ubuntu-latest
    env:
      IS_PUBLIC: ${{ github.event.inputs.is_public }}
      STATE_JSON: ${{ secrets.NOTE_STORAGE_STATE_JSON }}
      START_URL: https://editor.note.com/new
    outputs:
      final_url: ${{ steps.publish.outputs.published_url || steps.publish.outputs.draft_url }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
      - name: Install dependencies
        run: |
          npm install
          npx playwright install --with-deps chromium | cat
      - name: Prepare storageState
        id: state
        run: |
          test -n "$STATE_JSON" || (echo "ERROR: NOTE_STORAGE_STATE_JSON secret is not set" && exit 1)
          mkdir -p "$RUNNER_TEMP"
          echo "$STATE_JSON" > "$RUNNER_TEMP/note-state.json"
          echo "STATE_PATH=$RUNNER_TEMP/note-state.json" >> $GITHUB_OUTPUT
      - name: Ensure jq
        run: |
          if ! command -v jq >/dev/null 2>&1; then
            sudo apt-get update -y
            sudo apt-get install -y jq
          fi
      - name: Restore final
        id: draft
        env:
          FINAL_B64: ${{ needs.factcheck.outputs.final_b64 }}
        run: |
          test -n "$FINAL_B64" || { echo "final_b64 output is empty"; exit 1; }
          echo "$FINAL_B64" | base64 -d > final.json || echo "$FINAL_B64" | base64 --decode > final.json
          echo "TITLE=$(jq -r .title final.json)" >> $GITHUB_OUTPUT
          echo "TAGS=$(jq -r '.tags | join(", ")' final.json)" >> $GITHUB_OUTPUT

      - name: Publish via Playwright (Stealth Mode)
        id: publish
        env:
          TITLE: ${{ steps.draft.outputs.TITLE }}
          TAGS: ${{ steps.draft.outputs.TAGS }}
          STATE_PATH: ${{ steps.state.outputs.STATE_PATH }}
        shell: bash
        run: |
          set -o pipefail
          
          mkdir -p screenshots

          cat > post.mjs <<'EOF'
          import { chromium } from 'playwright';
          import { marked } from 'marked';
          import fs from 'fs';
          import os from 'os';
          import path from 'path';

          function nowStr(){ const d=new Date(); const z=n=>String(n).padStart(2,'0'); return `${d.getFullYear()}-${z(d.getMonth()+1)}-${z(d.getDate())}_${z(d.getHours())}-${z(d.getMinutes())}-${z(d.getSeconds())}`; }
          const SS_PATH = path.join(process.cwd(), 'screenshots', `note-post-${nowStr()}.png`);

          const STATE_PATH=process.env.STATE_PATH;
          // ‚òÖ‰øÆÊ≠£Ê∏à„Åø: Ê≠£„Åó„ÅÑURLÊñáÂ≠óÂàó
          const START_URL=process.env.START_URL||'https://editor.note.com/new';
          
          const rawTitle=process.env.TITLE||'';
          const rawFinal=JSON.parse(fs.readFileSync('final.json','utf8'));
          const rawBody=String(rawFinal.body||'');
          const TAGS=process.env.TAGS||'';
          const IS_PUBLIC=String(process.env.IS_PUBLIC||'false')==='true';

          function sanitizeTitle(t){ let s=String(t||'').trim().replace(/^```[a-zA-Z0-9_-]*\s*$/,'').replace(/^```$/,'').replace(/^#+\s*/,'').replace(/^"+|"+$/g,'').replace(/^'+|'+$/g,'').replace(/^`+|`+$/g,'').replace(/^json$/i,'').trim(); if(/^[\{\}\[\]\(\)\s]*$/.test(s)) s=''; if(!s) s='„Çø„Ç§„Éà„É´ÔºàËá™ÂãïÁîüÊàêÔºâ'; return s; }
          function deriveTitleFromMarkdown(md){ const lines=String(md||'').split(/\r?\n/); for (const line of lines){ const l=line.trim(); if(!l) continue; const m=l.match(/^#{1,3}\s+(.+)/); if(m) return sanitizeTitle(m[1]); if(!/^```|^>|^\* |^- |^\d+\. /.test(l)) return sanitizeTitle(l); } return ''; }
          function normalizeBullets(md){ return String(md||'').replace(/^\s*[‚Ä¢„Éª]\s?/gm,'- ').replace(/^\s*‚ó¶\s?/gm,'  - '); }
          function unwrapParagraphs(md){ const lines=String(md||'').split(/\r?\n/); const out=[]; let buf=''; let inFence=false; for(const raw of lines){ const line=raw.replace(/\u200B/g,''); if(/^```/.test(line)){ inFence=!inFence; buf+=line+'\n'; continue; } if(inFence){ buf+=line+'\n'; continue; } if(/^\s*$/.test(line)){ if(buf) out.push(buf.trim()); out.push(''); buf=''; continue; } if(/^(#{1,6}\s|[-*+]\s|\d+\.\s|>\s)/.test(line)){ if(buf){ out.push(buf.trim()); buf=''; } out.push(line.replace(/\s+$/,'')); continue; } if(buf){ buf += (/[„ÄÇ.!?)]$/.test(buf) ? '\n' : ' ') + line.trim(); } else { buf = line.trim(); } } if(buf) out.push(buf.trim()); return out.join('\n'); }
          
          function preferBareUrls(md){ const embedDomains=['openai.com','youtube.com','youtu.be','x.com','twitter.com','speakerdeck.com','slideshare.net','google.com','maps.app.goo.gl','gist.github.com']; return String(md||'').replace(/\[([^\]]+)\]\((https?:\/\/[^\s)]+)\)/g,(m,text,url)=>{ try{ const u=new URL(url); const host=u.hostname.replace(/^www\./,''); const isEmbed = embedDomains.some(d=>host.endsWith(d) || (url.includes('google.com/maps') && d.includes('google.com'))); return isEmbed ? `${text}\n${url}\n` : `${text} (${url})`; }catch{return `${text} ${url}`;} }); }
          
          function normalizeListItemSoftBreaks(md){ const lines=String(md||'').split(/\r?\n/); const out=[]; let inItem=false; const listStartRe=/^(\s*)(?:[-*+]\s|\d+\.\s)/; for (let i=0;i<lines.length;i++){ const line=lines[i]; if (listStartRe.test(line)){ inItem=true; out.push(line.replace(/\s+$/,'')); continue; } if (inItem){ if (!line.trim()) { out.push(line); inItem=false; continue; } if (listStartRe.test(line)) { inItem=false; out.push(line); continue; } const last = out.pop() || ''; out.push(last + ' ' + line.trim()); continue; } out.push(line); } return out.join('\n'); }
          function mdToHtml(block){ try{ const maybe = JSON.parse(block); if (maybe && typeof maybe==='object' && !Array.isArray(maybe)){ const candidates=[maybe.body, maybe.draftBody, maybe.content, maybe.text]; const chosen=candidates.find(v=>typeof v==='string' && v.trim()); if (chosen) block = String(chosen); } }catch{} const isList = /^\s*(?:[-*+]\s|\d+\.\s)/.test(block); return String(marked.parse(block, { gfm:true, breaks: !isList, mangle:false, headerIds:false }) || ''); }
          function htmlFromMarkdown(md){ return String(marked.parse(md, { gfm:true, breaks:false, mangle:false, headerIds:false }) || ''); }
          async function insertHTML(page, locator, html){ await locator.click(); await locator.evaluate((el, html) => { el.focus(); const sel = window.getSelection(); const range = document.createRange(); range.selectNodeContents(el); range.collapse(false); sel.removeAllRanges(); sel.addRange(range); document.execCommand('insertHTML', false, html); }, html); }

          let TITLE=sanitizeTitle(rawTitle);
          let preBody = preferBareUrls(rawBody);
          preBody = normalizeBullets(preBody);
          preBody = normalizeListItemSoftBreaks(preBody);
          preBody = unwrapParagraphs(preBody);
          if(!TITLE || TITLE==='„Çø„Ç§„Éà„É´ÔºàËá™ÂãïÁîüÊàêÔºâ'){ const d=deriveTitleFromMarkdown(preBody); if(d) TITLE=d; }

          let browser, context, page;
          try{
            // üí° „Çπ„ÉÜ„É´„Çπ„É¢„Éº„ÉâÔºöBotÊ§úÁü•„ÇíÂõûÈÅø„Åô„ÇãÈáçË¶Å„Å™Ë®≠ÂÆö
            browser = await chromium.launch({ 
              headless: true, 
              args: [
                '--disable-blink-features=AutomationControlled', 
                '--no-sandbox', 
                '--disable-setuid-sandbox'
              ] 
            });

            if(!fs.existsSync(STATE_PATH)) throw new Error('STATE_PATH not found: ' + STATE_PATH);
            
            context = await browser.newContext({ 
              storageState: STATE_PATH, 
              locale: 'ja-JP',
              // ‰∏ÄËà¨ÁöÑ„Å™Chrome„Éñ„É©„Ç¶„Ç∂„Å´ÂÅΩË£Ö
              userAgent: 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36'
            });
            
            page = await context.newPage();
            
            // webdriver„Éó„É≠„Éë„ÉÜ„Ç£„ÇíÂâäÈô§ÔºàBotÊ§úÁü•ÂõûÈÅøÔºâ
            await page.addInitScript(() => {
              Object.defineProperty(navigator, 'webdriver', {
                get: () => undefined,
              });
            });

            page.setDefaultTimeout(60000);

            console.log('Navigating to:', START_URL);
            await page.goto(START_URL, { waitUntil: 'domcontentloaded' });
            await page.waitForTimeout(3000); // „Éö„Éº„Ç∏ÈÅ∑ÁßªÂæÖ„Å°

            const currentUrl = page.url();
            console.log('Current URL:', currentUrl);
            
            // „É≠„Ç∞„Ç§„É≥ÁîªÈù¢„Å∏È£õ„Å∞„Åï„Çå„Å¶„ÅÑ„Å™„ÅÑ„Åã„ÉÅ„Çß„ÉÉ„ÇØ
            if (currentUrl.includes('/login') || currentUrl.includes('auth') || currentUrl.includes('signin')) {
              console.error('ERROR: Redirected to Login page. Authentication failed.');
              try{ await page.screenshot({ path: SS_PATH, fullPage: true }); }catch{}
              process.exit(1);
            }

            await page.waitForSelector('textarea[placeholder*="„Çø„Ç§„Éà„É´"]', { timeout: 30000 });
            await page.fill('textarea[placeholder*="„Çø„Ç§„Éà„É´"]', TITLE);

            const bodyBox = page.locator('div[contenteditable="true"][role="textbox"]').first();
            await bodyBox.waitFor({ state: 'visible' });
            const htmlAll = htmlFromMarkdown(preBody);
            
            let pasted = false;
            try {
              const origin = new URL(START_URL).origin;
              await context.grantPermissions(['clipboard-read','clipboard-write'], { origin });
              await page.evaluate(async (html, plain) => {
                const item = new ClipboardItem({
                  'text/html': new Blob([html], { type: 'text/html' }),
                  'text/plain': new Blob([plain], { type: 'text/plain' }),
                });
                await navigator.clipboard.write([item]);
              }, htmlAll, preBody);
              await bodyBox.click();
              await page.keyboard.press('Control+V');
              await page.waitForTimeout(1000);
              pasted = true;
            } catch (e) { console.log('Clipboard paste failed, trying fallback...'); }
            if (!pasted) {
              await insertHTML(page, bodyBox, htmlAll);
              await page.waitForTimeout(1000);
            }

            if(!IS_PUBLIC){
              console.log('Attempting to save draft...');
              const saveBtn = page.locator('button:has-text("‰∏ãÊõ∏„Åç‰øùÂ≠ò"), [aria-label*="‰∏ãÊõ∏„Åç‰øùÂ≠ò"]').first();
              await saveBtn.waitFor({ state: 'visible' });

              let saved = false;
              for(let i=0; i<30; i++){
                if(await saveBtn.isEnabled()){
                  console.log('Save button is enabled. Clicking...');
                  await saveBtn.click();
                  try {
                    await Promise.race([
                      page.locator('text=‰øùÂ≠ò„Åó„Åæ„Åó„Åü').waitFor({ timeout: 5000 }),
                      page.waitForTimeout(3000)
                    ]);
                    saved = true;
                    break;
                  } catch(e) { console.log('Click processed but confirmation timeout. Continuing check...'); }
                }
                console.log('Waiting for Save button to become enabled...');
                await page.waitForTimeout(1000);
              }
              
              if(!saved) console.warn('WARNING: Could not confirm draft save.');

              await page.screenshot({ path: SS_PATH, fullPage: true });
              console.log('DRAFT_URL=' + page.url());
              console.log('SCREENSHOT=' + SS_PATH);
              process.exit(0);
            }

            const proceed = page.locator('button:has-text("ÂÖ¨Èñã„Å´ÈÄ≤„ÇÄ")').first();
            await proceed.waitFor({ state: 'visible' });
            for (let i=0;i<30;i++){ if (await proceed.isEnabled()) break; await page.waitForTimeout(1000); }
            await proceed.click({ force: true });

            await Promise.race([
              page.waitForURL(/\/publish/i).catch(() => {}),
              page.locator('button:has-text("ÊäïÁ®ø„Åô„Çã")').first().waitFor({ state: 'visible' }).catch(() => {}),
            ]);

            const tags=(TAGS||'').split(/[\n,]/).map(s=>s.trim()).filter(Boolean);
            if(tags.length){
              let tagInput=page.locator('input[placeholder*="„Éè„ÉÉ„Ç∑„É•„Çø„Ç∞"]');
              if(!(await tagInput.count())) tagInput=page.locator('input[role="combobox"]').first();
              await tagInput.waitFor({ state: 'visible' });
              for(const t of tags){ await tagInput.click(); await tagInput.fill(t); await page.keyboard.press('Enter'); await page.waitForTimeout(120); }
            }

            const publishBtn = page.locator('button:has-text("ÊäïÁ®ø„Åô„Çã")').first();
            await publishBtn.waitFor({ state: 'visible' });
            for (let i=0;i<30;i++){ if (await publishBtn.isEnabled()) break; await page.waitForTimeout(100); }
            await publishBtn.click({ force: true });

            await Promise.race([
              page.waitForURL(u => !/\/publish/i.test(typeof u === 'string' ? u : u.toString()), { timeout: 20000 }).catch(() => {}),
              page.locator('text=ÊäïÁ®ø„Åó„Åæ„Åó„Åü').first().waitFor({ timeout: 8000 }).catch(() => {}),
              page.waitForTimeout(5000),
            ]);

            await page.screenshot({ path: SS_PATH, fullPage: true });
            const finalUrl=page.url();
            console.log('PUBLISHED_URL=' + finalUrl);
            console.log('SCREENSHOT=' + SS_PATH);
          } catch (error) {
            console.error('FATAL ERROR:', error.message);
            try { 
              if (page) await page.screenshot({ path: SS_PATH, fullPage: true }); 
              console.log('SCREENSHOT=' + SS_PATH);
            } catch {}
            process.exit(1);
          } finally {
            try{ await browser?.close(); }catch{}
          }
          EOF
          node post.mjs | tee post.log
          url=$(grep '^PUBLISHED_URL=' post.log | tail -n1 | cut -d'=' -f2-)
          draft=$(grep '^DRAFT_URL=' post.log | tail -n1 | cut -d'=' -f2-)
          shot=$(grep '^SCREENSHOT=' post.log | tail -n1 | cut -d'=' -f2-)
          if [ -n "$url" ]; then echo "published_url=$url" >> $GITHUB_OUTPUT; fi
          if [ -n "$draft" ]; then echo "draft_url=$draft" >> $GITHUB_OUTPUT; fi
          if [ -n "$shot" ]; then echo "screenshot=$shot" >> $GITHUB_OUTPUT; fi

      # üí° „Çπ„ÇØ„É™„Éº„É≥„Ç∑„Éß„ÉÉ„Éà„ÇíÁ¢∫ÂÆü„Å´„Ç¢„ÉÉ„Éó„É≠„Éº„ÉâÔºà„Ç®„É©„ÉºÊôÇ„ÇÇÂÆüË°åÔºâ
      - name: Upload screenshot (always)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: note-screenshot
          path: screenshots/
          if-no-files-found: warn